# BOJ 1920 수 찾기

- 티어: 실버 IV
- 난이도(체감): 하
- 아이디어: 입력 배열 A를 오름차순으로 정렬한 뒤, 질의값 x가 존재하는지 이분 탐색으로 확인한다. 표준 라이브러리 sort.SearchInts를 쓰면 깔끔하게 구현 가능.
- 복잡도: 정렬 O(N log N) + 질의 M개 × O(log N) → O((N+M) log N)
- 풀이 일자: 2025-09-03
- 재풀이 일자: 2025-09-10

## 회고

- SearchInts의 반환 의미(“첫 >= x 위치”)를 정확히 알면 구현이 쉬워진다.
- 이분 탐색은 정렬이 선행 조건. 정렬을 빼먹으면 오답/무한루프 위험.
- sort.SearchInts 자체가 내부에서 이분 탐색을 실행

- num이 모두보다 크면 len(aArr)를 반환하므로 인덱스 접근 전 경계 체크 필수.

- slice를 생성 시 ([]int,N)은 0으로 채우는 것. ([]int,0,N)은 cap만 N으로 만드는 것. 주의

## 키워드

- search/binary-search,
- sort/ascending,
- algo/lookup
- ds/array
- retry

### 이분 탐색(Binary Search)이란?

정렬된 구간에서 절반씩 범위를 줄여가며 목표값을 찾는 탐색 알고리즘. 항상 정렬(또는 단조성)이 전제조건!

#### 동작 개념

탐색 구간을 [lo, hi]로 두고, 중간 mid = (lo+hi)/2를 본다.

A[mid]와 x를 비교:

A[mid] == x → 찾음.

A[mid] < x → 왼쪽은 모두 작으니 오른쪽으로 (lo = mid + 1).

A[mid] > x → 오른쪽은 모두 크니 왼쪽으로 (hi = mid - 1).

lo > hi가 되면 없음.

#### 올바름의 핵심(불변식)

매 단계에서 정답이 있을 수 있는 구간만 남긴다.

정렬/단조성을 이용해 절반을 버려도 정답 가능성을 잃지 않는다.

#### 복잡도

매 단계마다 탐색 구간이 절반으로 줄어 O(log N).
